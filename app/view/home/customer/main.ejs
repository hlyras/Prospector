<style>
  canvas {
    touch-action: none;
  }
</style>

<script>
  document.addEventListener("DOMContentLoaded", () => {
    let customer_icon = document.getElementById("customer-icon");

    customer_icon.addEventListener("click", async () => {
      let user_create_interface = await userCreateInterface();
      lib.popup(user_create_interface, null, true);

      const upload = document.getElementById('upload');
      const canvas = document.getElementById('canvas');
      const ctx = canvas.getContext('2d', { willReadFrequently: true });

      let zoom = 1;
      let minZoom = 0.5;
      let maxZoom = 5;

      let panX = 0;
      let panY = 0;
      let isPanning = false;
      let lastMouse = { x: 0, y: 0 };

      let image = new Image();
      let crop = { x: 50, y: 50, width: 50, height: 50 };
      let dragging = false;
      let resizing = false;
      let offsetX, offsetY;
      let dragCorner = null;
      const handleSize = 10;

      let dragStart = null;

      upload.addEventListener('change', (e) => {
        ajustarTamanhoCanvas();

        const file = e.target.files[0];
        if (!file) return;

        // verifica√ß√£o pelo tipo MIME
        if (file.type === "application/pdf") {
          console.log("√â um PDF!");
        }

        lib.display("cart-icon", "");
        lib.display("search-bar", "");

        const reader = new FileReader();
        reader.onload = function (event) {
          image.onload = () => {
            // üîπ Etapa 1: redimensionar imagem mantendo propor√ß√£o
            let width = image.width;
            let height = image.height;

            if (width < height) {
              const scale = 500 / width;
              width = 500;
              height = height * scale;
            } else {
              const scale = 500 / height;
              height = 500;
              width = width * scale;
            }

            // Criar um canvas tempor√°rio para gerar a imagem redimensionada
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = width;
            tempCanvas.height = height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.drawImage(image, 0, 0, width, height);

            // Substitui a imagem original pela vers√£o redimensionada
            const resizedImage = new Image();
            resizedImage.onload = () => {
              // üîπ Etapa 2: prossegue com o seu fluxo atual
              const rect = canvas.getBoundingClientRect();
              canvas.width = Math.floor(rect.width);
              if (canvas.width <= 300) {
                canvas.height = Math.floor(rect.width);
              } else {
                canvas.height = 300;
              }

              // calcular propor√ß√£o e posi√ß√£o centralizada
              const scale = Math.min(canvas.width / resizedImage.width, canvas.height / resizedImage.height);
              const scaledWidth = resizedImage.width * scale;
              const scaledHeight = resizedImage.height * scale;
              const dx = (canvas.width - scaledWidth) / 2;
              const dy = (canvas.height - scaledHeight) / 2;

              // salvar para uso posterior no recorte
              resizedImage._drawData = { dx, dy, scaledWidth, scaledHeight };
              image = resizedImage;

              draw();
              aplicarZoom(0.9);
              detectarLogo();
              recortar();
            };
            resizedImage.src = tempCanvas.toDataURL();
          };
          image.src = event.target.result;
        };
        reader.readAsDataURL(file);
      });

      function ajustarTamanhoCanvas() {
        const rect = canvas.getBoundingClientRect();
        canvas.width = Math.floor(rect.width);
        canvas.height = Math.floor(rect.height);
      }

      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const { scaledWidth, scaledHeight } = image._drawData;
        const zoomedWidth = scaledWidth * zoom;
        const zoomedHeight = scaledHeight * zoom;

        const offsetX = (canvas.width - zoomedWidth) / 2 + panX;
        const offsetY = (canvas.height - zoomedHeight) / 2 + panY;

        image._zoomData = { offsetX, offsetY, zoomedWidth, zoomedHeight };

        ctx.drawImage(image, offsetX, offsetY, zoomedWidth, zoomedHeight);
        drawCropRect();
      }

      function drawCropRect() {
        ctx.strokeStyle = 'red';
        ctx.lineWidth = 1;
        ctx.strokeRect(crop.x, crop.y, crop.width, crop.height);

        // desenha al√ßas nos cantos
        drawHandle(crop.x, crop.y);
        drawHandle(crop.x + crop.width, crop.y);
        drawHandle(crop.x, crop.y + crop.height);
        drawHandle(crop.x + crop.width, crop.y + crop.height);
      }

      function drawHandle(x, y) {
        ctx.fillStyle = '#000';
        ctx.fillRect(x - handleSize / 2, y - handleSize / 2, handleSize, handleSize);
      }

      function limitarCropDentroDaImagem() {
        const { offsetX, offsetY, zoomedWidth, zoomedHeight } = image._zoomData;

        // Limitar X e largura
        if (crop.x < offsetX) {
          crop.width -= (offsetX - crop.x);
          crop.x = offsetX;
        }
        if (crop.x + crop.width > offsetX + zoomedWidth) {
          crop.width = offsetX + zoomedWidth - crop.x;
        }

        // Limitar Y e altura
        if (crop.y < offsetY) {
          crop.height -= (offsetY - crop.y);
          crop.y = offsetY;
        }
        if (crop.y + crop.height > offsetY + zoomedHeight) {
          crop.height = offsetY + zoomedHeight - crop.y;
        }

        // Garantir largura e altura m√≠nimas positivas
        crop.width = Math.max(1, crop.width);
        crop.height = Math.max(1, crop.height);
      }

      function limitarPosicaoDoCropDentroDaImagem() {
        const { offsetX, offsetY, zoomedWidth, zoomedHeight } = image._zoomData;

        const maxX = offsetX + zoomedWidth - crop.width;
        const maxY = offsetY + zoomedHeight - crop.height;

        // Garante que crop.width/height nunca sejam maiores que a imagem
        if (crop.width > zoomedWidth) crop.width = zoomedWidth;
        if (crop.height > zoomedHeight) crop.height = zoomedHeight;

        // Limita a posi√ß√£o (sem sair da imagem)
        crop.x = Math.min(Math.max(crop.x, offsetX), maxX);
        crop.y = Math.min(Math.max(crop.y, offsetY), maxY);
      };

      canvas.addEventListener('mousedown', (e) => {
        const mouse = getMouse(e);

        // 1. Tenta detectar redimensionamento
        dragCorner = getHandleUnderMouse(mouse.x, mouse.y);
        if (dragCorner) {
          resizing = true;
          return;
        }

        // 2. Se clicou dentro da √°rea do crop, ativa movimento
        if (
          mouse.x >= crop.x &&
          mouse.x <= crop.x + crop.width &&
          mouse.y >= crop.y &&
          mouse.y <= crop.y + crop.height
        ) {
          dragging = true;
          dragStart = {
            mouseX: mouse.x,
            mouseY: mouse.y,
            cropX: crop.x,
            cropY: crop.y,
          };
          return;
        }

        // 3. Se clicou fora da √°rea do crop, ativa pan
        isPanning = true;
        lastMouse = mouse;
      });

      canvas.addEventListener('mousemove', (e) => {
        const mouse = getMouse(e);

        if (!image || !image._zoomData) return;

        if (resizing && dragCorner) {
          // Redimensionando a √°rea de recorte
          resizeCrop(mouse.x, mouse.y);
          limitarCropDentroDaImagem();
        } else if (dragging && dragStart) {
          // Movendo a √°rea de recorte
          const deltaX = mouse.x - dragStart.mouseX;
          const deltaY = mouse.y - dragStart.mouseY;

          crop.x = dragStart.cropX + deltaX;
          crop.y = dragStart.cropY + deltaY;

          limitarPosicaoDoCropDentroDaImagem();
        } else if (isPanning && lastMouse) {
          // Arrastando a imagem (pan)
          // panX += mouse.x - lastMouse.x;
          // panY += mouse.y - lastMouse.y;
          // lastMouse = mouse;
        }

        draw(); // redesenha sempre no final
      });

      canvas.addEventListener("mouseup", () => {
        dragging = false;
        resizing = false;
        isPanning = false;
        dragCorner = null;
        dragStart = null;

        if (image._zoomData) {
          recortar();
        }
      });

      canvas.addEventListener("mouseleave", () => {
        if (resizing) {
          dragging = false;
          resizing = false;
          isPanning = false;
          dragCorner = null;
          dragStart = null;

          if (image._zoomData) {
            recortar();
          }
        }
      });

      // ====== SUPORTE TOUCH (apenas redimensionar e arrastar crop) ======
      canvas.addEventListener("touchstart", (e) => {
        if (!image || !image._zoomData) return;
        const touch = e.touches[0];
        const mouse = getMouse(touch);

        dragCorner = getHandleUnderMouse(mouse.x, mouse.y);
        if (dragCorner) {
          resizing = true;
          return;
        }

        if (isInsideCrop(mouse.x, mouse.y)) {
          dragging = true;
          dragStart = {
            mouseX: mouse.x,
            mouseY: mouse.y,
            cropX: crop.x,
            cropY: crop.y,
          };
        }
      });

      canvas.addEventListener("touchmove", (e) => {
        if (!image || !image._zoomData) return;
        e.preventDefault(); // evita rolagem na tela

        const touch = e.touches[0];
        const mouse = getMouse(touch);

        if (resizing && dragCorner) {
          resizeCrop(mouse.x, mouse.y);
          limitarCropDentroDaImagem();
        } else if (dragging && dragStart) {
          crop.x = dragStart.cropX + (mouse.x - dragStart.mouseX);
          crop.y = dragStart.cropY + (mouse.y - dragStart.mouseY);
          limitarPosicaoDoCropDentroDaImagem();
        }

        draw();
      });

      canvas.addEventListener("touchend", () => {
        if (!image || !image._zoomData) return;
        resizing = false;
        dragging = false;
        dragCorner = null;
        dragStart = null;

        recortar();
      });

      function getMouse(e) {
        const rect = canvas.getBoundingClientRect();
        return {
          x: e.clientX - rect.left,
          y: e.clientY - rect.top
        };
      }

      function isInsideCrop(x, y) {
        return x >= crop.x && x <= crop.x + crop.width &&
          y >= crop.y && y <= crop.y + crop.height;
      }

      function getHandleUnderMouse(x, y) {
        const corners = [
          { name: 'tl', x: crop.x, y: crop.y },
          { name: 'tr', x: crop.x + crop.width, y: crop.y },
          { name: 'bl', x: crop.x, y: crop.y + crop.height },
          { name: 'br', x: crop.x + crop.width, y: crop.y + crop.height },
        ];

        for (const corner of corners) {
          if (
            x >= corner.x - handleSize && x <= corner.x + handleSize &&
            y >= corner.y - handleSize && y <= corner.y + handleSize
          ) {
            return corner.name;
          }
        }
        return null;
      }

      function resizeCrop(x, y) {
        switch (dragCorner) {
          case 'tl':
            crop.width += crop.x - x;
            crop.height += crop.y - y;
            crop.x = x;
            crop.y = y;
            break;
          case 'tr':
            crop.width = x - crop.x;
            crop.height += crop.y - y;
            crop.y = y;
            break;
          case 'bl':
            crop.width += crop.x - x;
            crop.x = x;
            crop.height = y - crop.y;
            break;
          case 'br':
            crop.width = x - crop.x;
            crop.height = y - crop.y;
            break;
        }

        limitarCropDentroDaImagem();
        // recortar();
        draw();
      }

      function detectarLogo(folga = 20) {
        if (!image || !image.complete) return;

        const aux = document.createElement("canvas");
        aux.width = image.width;
        aux.height = image.height;
        const auxCtx = aux.getContext("2d", { willReadFrequently: true });
        auxCtx.drawImage(image, 0, 0);

        const imageData = auxCtx.getImageData(0, 0, aux.width, aux.height);
        const { data, width, height } = imageData;

        function getPixelIndex(x, y) {
          return (y * width + x) * 4;
        }

        function getColorAt(x, y) {
          const i = getPixelIndex(x, y);
          return { r: data[i], g: data[i + 1], b: data[i + 2] };
        }

        const samples = [
          getColorAt(0, 0),
          getColorAt(width - 1, 0),
          getColorAt(0, height - 1),
          getColorAt(width - 1, height - 1),
        ];

        const bgColor = {
          r: samples.reduce((sum, c) => sum + c.r, 0) / 4,
          g: samples.reduce((sum, c) => sum + c.g, 0) / 4,
          b: samples.reduce((sum, c) => sum + c.b, 0) / 4,
        };

        function colorDistance(c1, c2) {
          return Math.sqrt(
            Math.pow(c1[0] - c2[0], 2) +
            Math.pow(c1[1] - c2[1], 2) +
            Math.pow(c1[2] - c2[2], 2)
          );
        }

        const tolerance = 64;

        // coletar cores e contar frequ√™ncia
        let top = height, bottom = 0, left = width, right = 0;
        const freq = new Map();

        for (let y = 0; y < height; y++) {
          for (let x = 0; x < width; x++) {
            const i = getPixelIndex(x, y);
            const color = [data[i], data[i + 1], data[i + 2]];

            if (colorDistance(color, [bgColor.r, bgColor.g, bgColor.b]) > tolerance) {
              if (y < top) top = y;
              if (y > bottom) bottom = y;
              if (x < left) left = x;
              if (x > right) right = x;

              const key = color.join(",");
              freq.set(key, (freq.get(key) || 0) + 1);
            }
          }
        }

        // ordenar cores por frequ√™ncia
        const sortedColors = [...freq.entries()]
          .sort((a, b) => b[1] - a[1])
          .map(([key]) => key.split(",").map(Number));

        // selecionar at√© 5 cores bem distintas
        const suggested_colors = [];
        const minDistancia = 80;

        for (const cor of sortedColors) {
          let distante = true;
          for (const sel of suggested_colors) {
            if (colorDistance(cor, sel) < minDistancia) {
              distante = false;
              break;
            }
          }
          if (distante) {
            suggested_colors.push(cor);
          }
          if (suggested_colors.length >= 5) break;
        }

        // aplicar folga no crop
        top = Math.max(0, top - folga * 2);
        bottom = Math.min(height, bottom + folga * 2);
        left = Math.max(0, left - folga * 4);
        right = Math.min(width, right + folga * 4);

        const largura = right - left;
        const altura = bottom - top;

        if (largura < altura) {
          const diff = altura - largura;
          left = Math.max(0, left - Math.floor(diff / 2));
          right = Math.min(width, right + Math.ceil(diff / 2));
          if (right - left < altura) {
            right = Math.min(width, left + altura);
            left = Math.max(0, right - altura);
          }
        }

        const { offsetX, offsetY, zoomedWidth, zoomedHeight } = image._zoomData;
        const scaleX = zoomedWidth / image.width;
        const scaleY = zoomedHeight / image.height;

        crop.x = offsetX + left * scaleX;
        crop.y = offsetY + top * scaleY;
        crop.width = (right - left) * scaleX;
        crop.height = (bottom - top) * scaleY;

        limitarCropDentroDaImagem();
        recortar();
        draw();
      };

      function recortar() {
        const { offsetX, offsetY, zoomedWidth, zoomedHeight } = image._zoomData;
        const imgWidth = image.width;
        const imgHeight = image.height;

        const scaleX = imgWidth / zoomedWidth;
        const scaleY = imgHeight / zoomedHeight;

        // calcular coordenadas do recorte no canvas vis√≠vel
        const sx = (crop.x - offsetX) * scaleX;
        const sy = (crop.y - offsetY) * scaleY;
        const sw = crop.width * scaleX;
        const sh = crop.height * scaleY;

        // tamanho de sa√≠da proporcional (alta qualidade)
        const cropCanvas = document.createElement("canvas");
        cropCanvas.width = Math.round(sw);
        cropCanvas.height = Math.round(sh);

        const cropCtx = cropCanvas.getContext("2d");
        cropCtx.drawImage(
          image,
          sx, sy, sw, sh, // √°rea original
          0, 0, sw, sh // destino no novo canvas
        );

        const dataURL = cropCanvas.toDataURL("image/png");

        const logo_img = document.getElementById("logo-img");
        logo_img.src = dataURL;

        logo_img.onload = () => {
          let header_colors = analisarBordas(logo_img);
          let header_color = document.getElementById("header-bg");
          header_color.style.backgroundColor = lib.rgbToHex(`rgb(${header_colors[0].r},${header_colors[0].g},${header_colors[0].b})`);
          document.getElementById("header-color-picker").value = lib.rgbToHex(`rgb(${header_colors[0].r},${header_colors[0].g},${header_colors[0].b})`);

          let header_color_box = document.getElementById("header-color-box");
          header_color_box.innerHTML = "";

          for (let i = 0; i < 12; i++) {
            let c = header_colors[i];
            if (!c) continue;

            let color_div = lib.element.create("div", {
              class: "mobile-box b6 radius-3 shadow-lg-st border height-25 margin-top-5",
              style: `background-color: ${lib.rgbToHex(
                `rgb(${c.r},${c.g},${c.b})`
              )}`
            });
            header_color_box.append(color_div);

            color_div.addEventListener("click", () => {
              header_color.style.backgroundColor = lib.rgbToHex(`rgb(${c.r},${c.g},${c.b})`);
              document.getElementById("header-color-picker").value = lib.rgbToHex(`rgb(${c.r},${c.g},${c.b})`);
              setIconColor(logo_img, c);
              window.scrollTo({ top: 0, behavior: "smooth" });
            });
          };

          setIconColor(logo_img, header_colors[0]);
        };
      };

      function setIconColor(logo_img, header_color) {
        let icon_colors = getIconColor(logo_img, header_color);
        let cart_icon = document.getElementById("cart-icon");
        let search_icon = document.getElementById("search-icon");
        let menu_icon = document.getElementById("menu-icon");
        cart_icon.style.setProperty("--cart-color", lib.rgbToHex(`rgb(${icon_colors[0].r},${icon_colors[0].g},${icon_colors[0].b})`));
        search_icon.style.setProperty("--search-color", lib.rgbToHex(`rgb(${icon_colors[0].r},${icon_colors[0].g},${icon_colors[0].b})`));
        menu_icon.style.setProperty("--menu-color", lib.rgbToHex(`rgb(${icon_colors[0].r},${icon_colors[0].g},${icon_colors[0].b})`));
        document.getElementById("icon-color-picker").value = lib.rgbToHex(`rgb(${icon_colors[0].r},${icon_colors[0].g},${icon_colors[0].b})`);

        let icon_color_box = document.getElementById("icon-color-box");
        icon_color_box.innerHTML = "";

        for (let i = 0; i < 12; i++) {
          let c = icon_colors[i];
          if (!c) continue;

          let color_div = lib.element.create("div", {
            class: "mobile-box b6 radius-3 shadow-lg-st border height-25 margin-top-5",
            style: `background-color: ${lib.rgbToHex(
              `rgb(${c.r},${c.g},${c.b})`
            )}`
          });
          icon_color_box.append(color_div);

          color_div.addEventListener("click", () => {
            cart_icon.style.setProperty("--cart-color", lib.rgbToHex(`rgb(${c.r},${c.g},${c.b})`));
            search_icon.style.setProperty("--search-color", lib.rgbToHex(`rgb(${c.r},${c.g},${c.b})`));
            menu_icon.style.setProperty("--menu-color", lib.rgbToHex(`rgb(${c.r},${c.g},${c.b})`));
            document.getElementById("icon-color-picker").value = lib.rgbToHex(`rgb(${c.r},${c.g},${c.b})`);
            window.scrollTo({ top: 0, behavior: "smooth" });
          });
        };
      }

      function analisarBordas(img, maxCores = 5, minDistancia = 40) {
        if (!img.complete || img.naturalWidth === 0) {
          console.warn("Imagem ainda n√£o carregada.");
          return;
        }

        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');

        canvas.width = img.naturalWidth;
        canvas.height = img.naturalHeight;
        ctx.drawImage(img, 0, 0);

        const width = canvas.width;
        const height = canvas.height;
        const imageData = ctx.getImageData(0, 0, width, height).data;

        const cores = {};

        // Coleta as cores das 3 primeiras fileiras
        for (let x = 0; x < width; x++) {
          for (let y = 0; y < 3; y++) {
            const i = (y * width + x) * 4;
            const r = imageData[i];
            const g = imageData[i + 1];
            const b = imageData[i + 2];
            const key = `${r},${g},${b}`;
            cores[key] = (cores[key] || 0) + 1;
          }
        }

        // Converte em array de objetos RGB + quantidade e ordena pela frequ√™ncia
        const relatorio = Object.entries(cores)
          .sort((a, b) => b[1] - a[1])
          .map(([rgbStr, quantidade]) => {
            const [r, g, b] = rgbStr.split(',').map(Number);
            return { r, g, b, quantidade };
          });

        // Fun√ß√£o para calcular dist√¢ncia euclidiana entre duas cores
        function colorDistance(c1, c2) {
          return Math.sqrt(
            Math.pow(c1.r - c2.r, 2) +
            Math.pow(c1.g - c2.g, 2) +
            Math.pow(c1.b - c2.b, 2)
          );
        }

        // Seleciona at√© 5 cores distintas
        const suggestedColors = [];
        for (const cor of relatorio) {
          if (suggestedColors.length === 0) {
            suggestedColors.push({ r: cor.r, g: cor.g, b: cor.b });
            continue;
          }

          let distante = true;
          for (const sel of suggestedColors) {
            if (colorDistance(cor, sel) < minDistancia) {
              distante = false;
              break;
            }
          }

          if (distante) {
            suggestedColors.push({ r: cor.r, g: cor.g, b: cor.b });
          }

          if (suggestedColors.length >= maxCores) break;
        }

        return suggestedColors;
      }

      function agruparCores(relatorio, maxCores = 5, minDistancia = 40) {
        function hexToRgb(hex) {
          const bigint = parseInt(hex, 16);
          return [
            (bigint >> 16) & 255,
            (bigint >> 8) & 255,
            bigint & 255
          ];
        }

        function colorDistance(c1, c2) {
          return Math.sqrt(
            Math.pow(c1[0] - c2[0], 2) +
            Math.pow(c1[1] - c2[1], 2) +
            Math.pow(c1[2] - c2[2], 2)
          );
        }

        const coresSelecionadas = [];

        for (const { cor } of relatorio) {
          const rgb = hexToRgb(cor);

          if (coresSelecionadas.length === 0) {
            coresSelecionadas.push({ cor, rgb });
            continue;
          }

          let distante = true;
          for (const sel of coresSelecionadas) {
            if (colorDistance(rgb, sel.rgb) < minDistancia) {
              distante = false;
              break;
            }
          }

          if (distante) {
            coresSelecionadas.push({ cor, rgb });
          }

          if (coresSelecionadas.length >= maxCores) break;
        }

        // retorna s√≥ os hex
        return coresSelecionadas.map(c => c.cor);
      };

      function aplicarZoom(fator) {
        const novoZoom = zoom * fator;
        if (novoZoom < minZoom || novoZoom > maxZoom) return;
        zoom = novoZoom;
        draw();
      };

      function hexToRgb(hex) {
        hex = hex.replace('#', '');
        if (hex.length === 3) {
          hex = hex.split('').map(c => c + c).join('');
        }
        const bigint = parseInt(hex, 16);
        return {
          r: (bigint >> 16) & 255,
          g: (bigint >> 8) & 255,
          b: bigint & 255
        };
      }

      function getIconColor(img, bgColor) {
        if (!img.complete || img.naturalWidth === 0) {
          console.warn("Imagem ainda n√£o carregada.");
          return [];
        }

        const canvas = document.createElement("canvas");
        const ctx = canvas.getContext("2d");
        canvas.width = img.naturalWidth;
        canvas.height = img.naturalHeight;
        ctx.drawImage(img, 0, 0);

        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height).data;
        const colorMap = new Map();
        const bgTolerance = 40;
        const quantizeStep = 16; // reduz a granularidade de cores para agrupar cores similares

        function quantize(v) {
          return Math.floor(v / quantizeStep) * quantizeStep;
        }

        function rgbKey(r, g, b) {
          return `${r},${g},${b}`;
        }

        function isCloseToBg(r, g, b) {
          return (
            Math.abs(r - bgColor.r) < bgTolerance &&
            Math.abs(g - bgColor.g) < bgTolerance &&
            Math.abs(b - bgColor.b) < bgTolerance
          );
        }

        for (let i = 0; i < imageData.length; i += 4) {
          const a = imageData[i + 3];
          if (a < 100) continue;

          const r = quantize(imageData[i]);
          const g = quantize(imageData[i + 1]);
          const b = quantize(imageData[i + 2]);

          if (isCloseToBg(r, g, b)) continue;

          const key = rgbKey(r, g, b);
          colorMap.set(key, (colorMap.get(key) || 0) + 1);
        }

        const topColors = Array.from(colorMap.entries())
          .sort((a, b) => b[1] - a[1])
          .slice(0, 30)
          .map(([key, count]) => {
            const [r, g, b] = key.split(",").map(Number);
            return { r, g, b, count };
          });

        function getContrast(c1, c2) {
          const luminance = c => 0.299 * c.r + 0.587 * c.g + 0.114 * c.b;
          return Math.abs(luminance(c1) - luminance(c2));
        }

        let highestContrast = -1;
        let principalIndex = -1;

        topColors.forEach((color, index) => {
          const contrast = getContrast(color, bgColor);
          if (contrast > highestContrast) {
            highestContrast = contrast;
            principalIndex = index;
          }
        });

        return topColors.map((color, index) => ({
          r: color.r,
          g: color.g,
          b: color.b,
          principal: index === principalIndex
        }));
      };

      document.getElementById("header-color-picker").addEventListener("change", e => {
        document.getElementById("header-bg").style.backgroundColor = e.target.value;
        setIconColor(document.getElementById("logo-img"), hexToRgb(e.target.value));
        window.scrollTo({ top: 0, behavior: "smooth" });
      });

      document.getElementById("icon-color-picker").addEventListener("change", e => {
        let cart_icon = document.getElementById("cart-icon");
        let search_icon = document.getElementById("search-icon");
        let menu_icon = document.getElementById("menu-icon");
        cart_icon.style.setProperty("--cart-color", e.target.value);
        search_icon.style.setProperty("--search-color", e.target.value);
        menu_icon.style.setProperty("--menu-color", e.target.value);
        document.getElementById("icon-color-picker").value = e.target.value;
        window.scrollTo({ top: 0, behavior: "smooth" });
      });

      document.getElementById("style-confirm-btn").addEventListener("click", async () => {
        let customer_form = await userCreateForm();
        lib.popup(customer_form, null, true);

        customer_form.addEventListener("submit", async e => {
          e.preventDefault();

          let logo_image = lib.base64.toBlob(document.getElementById("logo-img").src);

          let customer = new FormData();
          customer.append('file', logo_image, "logo.webp");
          customer.append('business', customer_form.business.value);
          customer.append('domain', customer_form.domain.value);
          customer.append('email', customer_form.email.value);
          customer.append('password', customer_form.password.value);
          customer.append('color', document.getElementById("header-color-picker").value);
          customer.append('secondary_color', document.getElementById("icon-color-picker").value);

          let response = await API.response(Customer.create, customer);
          if (!response) { return; }

          lib.message(response, () => {
            lib.popout(customer_form);
            lib.popout(user_create_interface);

            lib.openExternalLink("https://app.cotalogo.com/user/login");
          });

          // console.log(response);
        });
      });
    });
  });

  async function userCreateInterface() {
    // ====== ESTILO (canvas) ======
    let styleTag = lib.element.create("style", {}, `
      canvas {
        border: 1px solid #ccc;
        cursor: crosshair;
      }

      .menu-icon {
    cursor: pointer;
  }

  .bar {
    width: 100%;
    height: 5px;
    width: 35px;
    transition: all 0.3s ease;
  }

  .menu-icon.open .bar:nth-child(1) {
    transform: translateY(6px) rotate(45deg);
  }

  .menu-icon.open .bar:nth-child(2) {
    opacity: 0;
  }

  .menu-icon.open .bar:nth-child(3) {
    transform: translateY(-6px) rotate(-45deg);
  }
    `);
    document.head.append(styleTag);

    // ====== BOX PRINCIPAL ======
    let user_create_interface = lib.element.create("div", {
      class: "box a1 container"
    });

    // ====== HEADER SECTION ======
    let header = lib.element.create("section", {
      id: "header-bg",
      class: "box a1 container padding-5",
      style: "background-color: transparent"
    });
    user_create_interface.append(header);

    // Linha principal (logo + login/cart)
    let headerMain = lib.element.create("div", {
      class: "box b1 container"
    });

    // ==== LOGO ====
    let logoContainer = lib.element.create("div", {
      class: "mobile-box a2-3 container padding-5 padding-left-10 noselect v-center",
      style: "overflow: hidden;"
    });
    let logoImg = lib.element.create("img", {
      id: "logo-img",
      src: "",
      class: "image-prop max-height-100 radius-5 opacity-out-09 transition-04-04 pointer",
      alt: ""
    });
    logoContainer.append(logoImg);
    headerMain.append(logoContainer);

    // ==== LOGIN + CARRINHO ====
    let rightContainer = lib.element.create("div", {
      class: "mobile-box b3 container v-center"
    });
    let innerRight = lib.element.create("div", {
      class: "mobile-box container nowrap center"
    });

    // √çcone do carrinho
    let cartIcon = lib.element.create("div", {
      id: "cart-icon",
      class: "cart-icon opacity-out-09 pointer",
      style: "--cart-color: transparent;display: none;"
    });
    let cartBasket = lib.element.create("div", { class: "cart-basket" });
    let cartLine = lib.element.create("div", { class: "cart-line" });
    let cartStrap = lib.element.create("div", { class: "cart-strap" });
    let cartWheelLeft = lib.element.create("div", { class: "cart-wheel-left" });
    let cartWheelRight = lib.element.create("div", { class: "cart-wheel-right" });

    cartIcon.append(cartBasket);
    cartIcon.append(cartLine);
    cartIcon.append(cartStrap);
    cartIcon.append(cartWheelLeft);
    cartIcon.append(cartWheelRight);

    innerRight.append(cartIcon);
    rightContainer.append(innerRight);
    headerMain.append(rightContainer);

    // ====== SEARCH BAR ======
    let searchBar = lib.element.create("div", {
      id: "search-bar",
      class: "box a1 container h-center",
      style: "top: 0;z-index: 10;display:none;"
    });
    let searchContainer = lib.element.create("div", {
      class: "box b2 container"
    });

    // Campo de busca
    let searchInput = lib.element.create("input", {
      type: "text",
      name: "name",
      class: "mobile-box b3-4 ground lucida-grande rem09 border radius-5 padding-5 padding-left-10 nofocus v-center",
      placeholder: "Digite o que procura...",
      role: "presentation",
      autocomplete: "off"
    });
    searchContainer.append(searchInput);

    // Bot√£o de busca
    let searchButton = lib.element.create("button", {
      class: "mobile-box b8 container noborder transparent"
    });
    let searchIcon = lib.element.create("div", {
      id: "search-icon",
      class: "mobile-box search-icon opacity-out-09 center pointer",
      style: "--search-color: transparent;"
    });
    searchIcon.append(lib.element.create("div", { class: "search-circle" }));
    searchIcon.append(lib.element.create("div", { class: "search-detail" }));
    searchIcon.append(lib.element.create("div", { class: "search-line" }));
    searchButton.append(searchIcon);
    searchContainer.append(searchButton);

    // √çcone do menu
    let menuWrapper = lib.element.create("div", {
      class: "mobile-box b8 container"
    });
    let menuIcon = lib.element.create("div", {
      id: "menu-icon",
      class: "mobile-box menu-icon open-btn padding-5",
      style: "--menu-color: transparent;"
    });
    let bar1 = lib.element.create("div", {
      class: "bar radius-2",
      style: "background-color: var(--menu-color)"
    });
    let bar2 = lib.element.create("div", {
      class: "bar radius-2 margin-top-5",
      style: "background-color: var(--menu-color)"
    });
    let bar3 = lib.element.create("div", {
      class: "bar radius-2 margin-top-5",
      style: "background-color: var(--menu-color)"
    });
    menuIcon.append(bar1);
    menuIcon.append(bar2);
    menuIcon.append(bar3);
    menuWrapper.append(menuIcon);
    searchContainer.append(menuWrapper);

    searchBar.append(searchContainer);

    // ====== MONTA TUDO ======
    header.append(headerMain);
    header.append(searchBar);

    // ====== √ÅREA ESQUERDA (upload + canvas) ======
    let leftBox = lib.element.create("div", { class: "box a2 container" });

    let uploadInput = lib.element.create("input", {
      type: "file",
      id: "upload",
      accept: "image/*, .pdf",
      hidden: ""
    });

    let uploadLabel = lib.element.create("label", {
      for: "upload",
      class: "mobile-box ground lucida-grande rem09 bold border shadow-lg-st radius-3 padding-10 margin-10 pointer"
    }, "üìÅ Enviar Logomarca");

    let canvas_div = lib.element.create("canvas", {
      id: "canvas",
      class: "box b1"
    });

    leftBox.append(uploadInput);
    leftBox.append(uploadLabel);
    leftBox.append(canvas_div);
    user_create_interface.append(leftBox);

    // ====== √ÅREA DIREITA (configura√ß√µes de cor) ======
    let rightBox = lib.element.create("div", {
      class: "container box b2 margin-top-3 h-center"
    });

    // -- Se√ß√£o: Cores de fundo --
    let bgBox = lib.element.create("div", {
      class: "container mobile-box b2 padding-5"
    });
    let bgLabel = lib.element.create("div", { class: "lucida-grande" }, "Cor de fundo");
    let bgColorBox = lib.element.create("div", {
      id: "header-color-box",
      class: "container a1"
    });
    let bgColorPickerLabel = lib.element.create("div", {
      class: "box b1 lucida-grande margin-top-5"
    }, "Cor personalizada");
    let bgColorPicker = lib.element.create("input", {
      type: "color",
      id: "header-color-picker"
    });

    bgBox.append(bgLabel);
    bgBox.append(bgColorBox);
    bgBox.append(bgColorPickerLabel);
    bgBox.append(bgColorPicker);
    rightBox.append(bgBox);

    // -- Se√ß√£o: Cores dos √≠cones --
    let iconBox = lib.element.create("div", {
      class: "container mobile-box b2 padding-5"
    });
    let iconLabel = lib.element.create("div", { class: "lucida-grande" }, "Cor dos √≠cones");
    let iconColorBox = lib.element.create("div", {
      id: "icon-color-box",
      class: "container a1"
    });

    let iconColorPickerLabel = lib.element.create("div", {
      class: "box b1 lucida-grande margin-top-5"
    }, "Cor personalizada");
    let iconColorPicker = lib.element.create("input", {
      type: "color",
      id: "icon-color-picker"
    });
    iconBox.append(iconLabel);
    iconBox.append(iconColorBox);
    iconBox.append(iconColorPickerLabel);
    iconBox.append(iconColorPicker);
    rightBox.append(iconBox);

    // -- Bot√£o: Voltar --
    let previousBtn = lib.element.create("div", {
      id: "style-previous-btn",
      class: "mobile-box lucida-grande rem09 bold border shadow-lg-st padding-10 padding-left-10 padding-right-10 margin-top-20 radius-5 pointer noselect"
    }, "‚óÄ Voltar");
    rightBox.append(previousBtn);

    // -- Bot√£o: Confirmar --
    let confirmBtn = lib.element.create("div", {
      id: "style-confirm-btn",
      class: "mobile-box btn-act lucida-grande rem09 bold shadow-lg-st padding-10 padding-left-10 padding-right-10 margin-top-20 radius-5 right pointer noselect"
    }, "Confirmar visual ‚ñ∂");
    rightBox.append(confirmBtn);

    user_create_interface.append(rightBox);

    return user_create_interface;
  };

  async function userCreateForm() {
    // Cria o formul√°rio principal
    let form = lib.element.create("form", {
      id: "signup-form",
      class: "box b3 container ground margin-top-15 padding-10"
    });

    // ====== T√çTULO ======
    let title = lib.element.create("div", {
      class: "box b1 underline lucida-grande rem10 bold margin-top-10 center noselect",
      style: "color: #222"
    }, "Criar conta");
    form.append(title);

    // ====== CAMPO: Nome da empresa ======
    let businessBox = lib.element.create("div", {
      class: "box b1 container margin-top-15"
    });
    let businessLabel = lib.element.create("span", {
      class: "box b1 lucida-grande rem08 bold",
      style: "color: #111"
    }, "Nome da empresa");
    let businessInput = lib.element.create("input", {
      type: "text",
      name: "business",
      class: "box b1 lucida-grande rem10 border-bottom-lg-st",
      maxlength: "60",
      placeholder: "Minha Empresa",
      role: "presentation",
      autocomplete: "off"
    });
    businessBox.append(businessLabel);
    businessBox.append(businessInput);
    form.append(businessBox);

    // ====== CAMPO: Dom√≠nio ======
    let domainBox = lib.element.create("div", {
      class: "box b1 container margin-top-15"
    });
    let domainLabel = lib.element.create("span", {
      class: "box b1 lucida-grande rem08 bold",
      style: "color: #111"
    }, "Escolha seu dom√≠nio");
    domainBox.append(domainLabel);

    let domainInputBox = lib.element.create("div", { class: "mobile-box" });
    let domainInput = lib.element.create("input", {
      type: "text",
      name: "domain",
      class: "mobile-box lucida-grande rem10 border-bottom-lg-st right",
      size: "10",
      oninput: "this.size = this.value.length >= 10 ? this.value.length : 10",
      maxlength: "60",
      placeholder: "meudominio",
      role: "presentation",
      autocomplete: "off"
    });
    domainInputBox.append(domainInput);

    let domainSuffix = lib.element.create("div", {
      class: "mobile-box lucida-grande rem10"
    }, ".cotalogo.com");

    domainBox.append(domainInputBox);
    domainBox.append(domainSuffix);
    form.append(domainBox);

    // ====== CAMPO: E-mail ======
    let emailBox = lib.element.create("div", {
      class: "box b1 container margin-top-15"
    });
    let emailLabel = lib.element.create("span", {
      class: "box b1 lucida-grande rem08 bold",
      style: "color: #111"
    }, "E-mail");
    let emailInput = lib.element.create("input", {
      type: "email",
      name: "email",
      id: "email",
      class: "box b1 lucida-grande rem10 border-bottom-lg-st",
      maxlength: "60",
      placeholder: "E-mail",
      role: "presentation",
      autocomplete: "off"
    });
    emailBox.append(emailLabel);
    emailBox.append(emailInput);
    form.append(emailBox);

    // ====== CAMPO: Senha ======
    let passwordBox = lib.element.create("div", {
      class: "box b1 container margin-top-15"
    });
    let passwordLabel = lib.element.create("span", {
      class: "box b1 lucida-grande rem08 bold"
    }, "Senha");

    let passwordContainer = lib.element.create("div", {
      class: "box b1 container"
    });
    let passwordInput = lib.element.create("input", {
      type: "password",
      name: "password",
      class: "mobile-box b9-10 lucida-grande rem10 border-bottom-lg-st",
      maxlength: "45",
      placeholder: "Senha",
      role: "presentation",
      autocomplete: "off"
    });
    let eyeContainer = lib.element.create("div", {
      class: "mobile-box b10 container center"
    });
    let eyeIcon = lib.element.create("img", {
      src: "/images/icon/eye-open.png",
      class: "image-prop icon size-20 center",
      onclick: "switchPasswordView(this)"
    });
    eyeContainer.append(eyeIcon);
    passwordContainer.append(passwordInput);
    passwordContainer.append(eyeContainer);

    passwordBox.append(passwordLabel);
    passwordBox.append(passwordContainer);
    form.append(passwordBox);

    // ====== BOT√ÉO DE ENVIO ======
    let submit = lib.element.create("input", {
      type: "submit",
      class: "box b1 btn-act lucida-grande rem10 bold radius-5 noborder shadow-lg-st padding-10 margin-top-10 margin-bottom-5 noselect pointer",
      value: "Criar minha conta"
    });
    form.append(submit);

    // ====== ADICIONAR AO DOM ======
    return form;
  };
</script>